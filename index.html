<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GooFit: The GooFit Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GooFit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The <a class="el" href="namespace_goo_fit.html">GooFit</a> Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Introduction </h1>
<p><a href="https://github.com/GooFit/GooFit">GooFit</a> (<a class="el" href="index.html#footnote1">1</a>) is a framework for creating arbitrary probability density functions (PDFs) and evaluating them over large datasets using nVidia Graphics Processing Units (GPUs). New PDFs are written partly in nVidia’s CUDA programming language and partly in C++; however, no expertise in CUDA is required to get started, because the already-existing PDFs can be put together in plain C++.</p>
<p>Aside from the mass of unenlightened hominids who have not yet discovered their need for a massively-parallel fitting framework, there are three kinds of <a class="el" href="namespace_goo_fit.html">GooFit</a> users:</p>
<ul>
<li>Initiates, who write “user-level code” - that is, code which instantiates existing PDF classes in some combination. No knowledge of CUDA is required for this level. If your data can be described by a combination of not-too-esoteric functions, even if the combination is complicated, then user code is sufficient. Section <a class="el" href="index.html#usercode">User code</a> gives an example of how to write a simple fit.</li>
<li>Acolytes, or advanced users, who have grasped the art of creating new PDF classes. This involves some use of CUDA, but is mainly a question of understanding the variable-index organisation that <a class="el" href="namespace_goo_fit.html">GooFit</a> PDFs use. Section <a class="el" href="index.html#newpdfs">New PDFs</a> considers this organisation in some depth.</li>
<li>Ascended Masters, or architects, who by extended meditation have acquired a full understanding of the core engine of <a class="el" href="namespace_goo_fit.html">GooFit</a>, and can modify it to their desire (<a class="el" href="index.html#footnote2">2</a>). Section <a class="el" href="index.html#engine">Engine</a> gives a detailed narrative of the progress of a PDF evaluation through the engine core, thus elucidating its mysteries. It should only rarely be necessary to acquire this level of mastery; in principle only the developers of <a class="el" href="namespace_goo_fit.html">GooFit</a> need to know its internal details.</li>
</ul>
<p>Aside from considerations of the user’s understanding, <a class="el" href="namespace_goo_fit.html">GooFit</a> does require a CUDA-capable graphics card to run on, with compute capability at least 2.1. Further, you will need nVidia’s CUDA SDK, in particular the <code>nvcc</code> compiler. Aside from this, <a class="el" href="namespace_goo_fit.html">GooFit</a> is known to compile and run on Fedora 14, Ubuntu 12.04, and OSX 10.8.4. It has been tested on the Tesla, Fermi, and Kepler generations of nVidia GPUs.</p>
<h2>Getting started </h2>
<p>You will need to have a CUDA-capable device and to have the development environment (also known as the software development kit or SDK) set up, with access to the compiler <code>nvcc</code> and its libraries. If you have the hardware, you can get the SDK from <a href="https://developer.nvidia.com/gpu-computing-sdk">nVidia’s website</a>.</p>
<p>With your CUDA environment set up, you can install <a class="el" href="namespace_goo_fit.html">GooFit</a> thus:</p>
<ul>
<li>Clone from the GitHub repository: <pre class="fragment">git clone git://github.com/GooFit/GooFit.git
cd GooFit
</pre></li>
<li><p class="startli">Compile with <code>cmake</code>: </p><pre class="fragment">mkdir build
cd build
cmake ..
make
</pre><p class="startli">Do not be alarmed by warning messages saying that such-and-such a function’s stack size could not be statically determined; this is an unavoidable (so far) side effect of the function-pointer implementation discussed in section <a class="el" href="index.html#engine">Engine</a>.</p>
</li>
<li><p class="startli">Run the ‘simpleFitExample’ program, which generates three distributions, fits them, and plots the results: </p><pre class="fragment">cd examples/simpleFit
./simpleFit
</pre><p class="startli">The expected output is a MINUIT log for three different fits, and three image files.</p>
</li>
<li>Run the Dalitz-plot tutorial, which fits a text file containing toy Monte Carlo data to a coherent sum of Breit-Wigner resonances: <pre class="fragment">cd examples/dalitz
./dalitz dalitz_toyMC_000.txt
</pre></li>
</ul>
<p>Quick troubleshooting: <a class="el" href="namespace_goo_fit.html">GooFit</a> uses <a href="https://cmake.org/cmake/help/v3.7/module/FindCUDA.html">FindCUDA</a>, and expects to find <code>root-config</code> in your path. Check the docs for FindCUDA if you need help locating your CUDA install.</p>
<p>The text file contains information about simulated decays of the \(D^0\) particle to \(\pi^+\pi^-\pi^0\); in particular, in each line, the second and third numbers are the Dalitz-plot coordinates \(m^2(pi^+\pi^0)\) and \(m^2(pi^-\pi^0)\). The <code>dalitz</code> program creates a PDF describing the distribution of these two variables in terms of Breit-Wigner resonances, reads the data, sends it to the GPU, and fits the PDF to the data - the floating parameters are the complex coefficients of the resonances. The expected output is a MINUIT fit log showing that the fit converged, with such-and-such values for the real and imaginary parts of the resonance coefficients.</p>
<h1><a class="anchor" id="usercode"></a>
User-level code </h1>
<p>From the outside, <a class="el" href="namespace_goo_fit.html">GooFit</a> code should look like ordinary, object-oriented C++ code: The CUDA parts are hidden away inside the engine, invisible to the user. Thus, to construct a simple Gaussian fit, merely declare three <code>Variable</code> objects and a <code>GaussianPdf</code> object that uses them, and create an appropriate <code>UnbinnedDataSet</code> to fit to:</p>
<h2><a class="anchor" id="listinggaussfit"></a>
Simple Gaussian fit </h2>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Optional, but highly recommended. Based loosly on TApplication.</span></div><div class="line">  <a class="code" href="class_goo_fit_1_1_application.html">GooFit::Application</a> app {<span class="stringliteral">&quot;Simple Gaussian Fit&quot;</span>, argc, argv};</div><div class="line"></div><div class="line">  <span class="comment">// Run the application parser, setup MPI if needed, and exit if parsing failed</span></div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">      app.<a class="code" href="class_goo_fit_1_1_application.html#a69289910ee9f552990c9c2b9ca253902">run</a>();</div><div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> GooFit::ParseError&amp; e) {</div><div class="line">      <span class="keywordflow">return</span> app.exit(e);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Create an object to represent the observable, </span></div><div class="line">  <span class="comment">// the number we have measured. Give it a name,</span></div><div class="line">  <span class="comment">// upper and lower bounds, and a number of bins</span></div><div class="line">  <span class="comment">// to use in numerical integration. </span></div><div class="line">  Variable xvar {<span class="stringliteral">&quot;xvar&quot;</span>, -5, 5}; </div><div class="line">  xvar.setNumBins(1000); </div><div class="line"></div><div class="line">  <span class="comment">// A data set to store our observations in.</span></div><div class="line">  UnbinnedDataSet data {xvar};</div><div class="line"></div><div class="line">  <span class="comment">// &quot;Observe&quot; ten thousand events and add them</span></div><div class="line">  <span class="comment">// to the data set, throwing out any events outside</span></div><div class="line">  <span class="comment">// the allowed range. In a real fit this step would</span></div><div class="line">  <span class="comment">// involve reading a previously created file of data</span></div><div class="line">  <span class="comment">// from an _actual_ experiment. </span></div><div class="line">  TRandom donram(42); </div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10000; ++i) {</div><div class="line">    <a class="code" href="namespace_goo_fit.html#a6f9643fed3185c9bcdfb118b67bb1b16">fptype</a> val = donram.Gaus(0.2, 1.1);</div><div class="line">    <span class="keywordflow">if</span> (fabs(val) &gt; 5) {--i; <span class="keywordflow">continue</span>;} </div><div class="line">    data.addEvent(val); </div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Variables to represent the mean and standard deviation</span></div><div class="line">  <span class="comment">// of the Gaussian PDF we&#39;re going to fit to the data.</span></div><div class="line">  <span class="comment">// They take a name, starting value, optional initial </span></div><div class="line">  <span class="comment">// step size and upper and lower bounds. Notice that</span></div><div class="line">  <span class="comment">// here only the mean is given a step size; the sigma</span></div><div class="line">  <span class="comment">// will use the default step of one-tenth of its range.</span></div><div class="line">  Variable mean {<span class="stringliteral">&quot;mean&quot;</span>, 0, 1, -10, 10};</div><div class="line">  Variable sigm {<span class="stringliteral">&quot;sigm&quot;</span>, 1, 0.5, 1.5}; </div><div class="line"></div><div class="line">  <span class="comment">// The actual PDF. The Gaussian takes a name, an independent</span></div><div class="line">  <span class="comment">// (ie observed) variable, and a mean and width. </span></div><div class="line">  GaussianPdf gauss {<span class="stringliteral">&quot;gauss&quot;</span>, &amp;xvar, &amp;mean, &amp;sigm}; </div><div class="line"></div><div class="line">  <span class="comment">// Copy the data to the GPU. </span></div><div class="line">  gauss.setData(&amp;data);</div><div class="line"></div><div class="line">  <span class="comment">// A class that talks to MINUIT and GooFit. It needs</span></div><div class="line">  <span class="comment">// to know what PDF it should set up in MINUIT. </span></div><div class="line">  <a class="code" href="namespace_goo_fit.html#a70f7cd945b885cb3e7fe175e45e3b668">FitManager</a> fitter {&amp;gauss}; </div><div class="line"></div><div class="line">  <span class="comment">// The actual fit. </span></div><div class="line">  fitter.<a class="code" href="class_goo_fit_1_1_fit_manager_minuit2.html#a027d883752759da2435dabb2396670b1">fit</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Notice that, behind the scenes, <a class="el" href="namespace_goo_fit.html">GooFit</a> assumes that there will be exactly one top-level PDF and data set; it is not advised to break this assumption unless you know what you are doing and exactly how you are getting around it.</p>
<h2>Data sets </h2>
<p>To create a data set with several dimensions, supply a <code>vector</code> of <code>Variables</code>:</p>
<div class="fragment"><div class="line">vector&lt;Variable*&gt; vars;</div><div class="line">Variable xvar {<span class="stringliteral">&quot;xvar&quot;</span>, -10, 10};</div><div class="line">Variable yvar {<span class="stringliteral">&quot;yvar&quot;</span>, -10, 10};</div><div class="line">vars.push_back(&amp;xvar);</div><div class="line">vars.push_back(&amp;yvar);</div><div class="line">UnbinnedDataSet data(vars);</div></div><!-- fragment --><p>In this case, to fill the data set, set the <code>Variable</code> values and call the <code>addEvent</code> method without arguments:</p>
<div class="fragment"><div class="line">xvar.setValue(3);</div><div class="line">yvar.setValue(-2);</div><div class="line">data.addEvent();</div></div><!-- fragment --><p>This will add an event with the current values of the <code>Variable</code> list to the data set. In general, where an unknown number of arguments are wanted, <a class="el" href="namespace_goo_fit.html">GooFit</a> prefers to use a <code>vector</code> of pointers.</p>
<h2>Fit types </h2>
<p>By default, <a class="el" href="namespace_goo_fit.html">GooFit</a> will do an unbinned maximum-likelihood fit, where the goodness-of-fit metric that is minimised (<a class="el" href="index.html#footnote3">3</a>) is the negative sum of logarithms of probabilities, which is equivalent to maximising the joint overall probability: </p><p class="formulaDsp">
\begin{align} \cal P &amp;=&amp; -2\sum\limits_{events} \log(P_i) \end{align}
</p>
<p> where \(P_i\) is the PDF value for event \(i\).</p>
<p>To get a binned fit, you should create a <code>BinnedDataSet</code> instead of the <code>UnbinnedDataSet</code>; the procedure is otherwise the same. Notice that the <code>BinnedDataSet</code> will use the number of bins that its constituent <code>Variable</code>s have at the moment of its creation. Supplying a <code>BinnedDataSet</code> to a <code>GooPdf</code> (which is the base class of all the <code>FooPdf</code> classes such as <code>GaussianPdf</code>) will, by default, make it do a binned negative-log-likelihood fit, in which the goodness-of-fit criterion is the sum of the logarithms of the Poisson probability of each bin: </p><p class="formulaDsp">
\begin{align} {\cal P} &amp;=&amp; -2*\sum\limits_{bins}(N * \log(E) - E) \end{align}
</p>
<p> where \(E\) is the expected number of events in a bin and \(N\) is the observed number.</p>
<p>There are two non-default variants of binned fits: A chisquare fit where the error on a bin entry is taken as the square root of the number of observed entries in it (or 1 if the bin is empty), and a “bin error” fit where the error on each bin is supplied by the <code>BinnedDataSet</code>. To do such a fit, in addition to supplying the <code>BinnedDataSet</code> (and providing the errors through the <code>setBinError</code> method in the case of the bin error fit), you should create a suitable <code>FitControl</code> object and send it to the top-level <code>GooPdf</code>:</p>
<div class="fragment"><div class="line">Variable decayTime {<span class="stringliteral">&quot;decayTime&quot;</span>, 100, 0, 10}; </div><div class="line">BinnedDataSet* ratioData {&amp;decayTime}; </div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i) {</div><div class="line">  ratioData.SetBinContent(getRatio(i));</div><div class="line">  ratioData.SetBinError(getError(i));</div><div class="line">}</div><div class="line"></div><div class="line">vector&lt;Variable*&gt; weights;</div><div class="line">weights.push_back(<span class="keyword">new</span> Variable(<span class="stringliteral">&quot;constaCoef&quot;</span>, 0.03, 0.01, -1, 1));</div><div class="line">weights.push_back(<span class="keyword">new</span> Variable(<span class="stringliteral">&quot;linearCoef&quot;</span>, 0, 0.01, -1, 1));</div><div class="line">weights.push_back(<span class="keyword">new</span> Variable(<span class="stringliteral">&quot;secondCoef&quot;</span>, 0, 0.01, -1, 1));</div><div class="line"></div><div class="line">PolynomialPdf poly {<span class="stringliteral">&quot;poly&quot;</span>, decayTime, weights}; </div><div class="line">poly.setFitControl(<span class="keyword">new</span> BinnedErrorFit()); </div><div class="line">poly.setData(&amp;ratioData); </div></div><!-- fragment --><p>The <code>FitControl</code> classes are <code>UnbinnedNLLFit</code> (the default), <code>BinnedNLLFit</code> (the default for binned fits), <code>BinnedErrorFit</code> and <code>BinnedChisqFit</code>.</p>
<h1><a class="anchor" id="newpdfs"></a>
Creating new PDF classes </h1>
<p>The simplest way to create a new PDF is to take the existing <code>GaussianPdf</code> class as a template. The existence of a <code>FooPdf.cu</code> file in the <code>FPOINTER</code> directory is, because of Makefile magic, sufficient to get the <code>Foo</code> PDF included in the <a class="el" href="namespace_goo_fit.html">GooFit</a> library. However, a certain amount of boilerplate is necessary to make the PDF actually work. First of all, it needs a device-side function with a particular signature:</p>
<h2><a class="anchor" id="listingfsign"></a>
Signature of evaluation functions. </h2>
<div class="fragment"><div class="line">__device__ <a class="code" href="namespace_goo_fit.html#a6f9643fed3185c9bcdfb118b67bb1b16">fptype</a> device_Gaussian (<a class="code" href="namespace_goo_fit.html#a6f9643fed3185c9bcdfb118b67bb1b16">fptype</a>* evt, </div><div class="line">                                   <a class="code" href="namespace_goo_fit.html#a6f9643fed3185c9bcdfb118b67bb1b16">fptype</a>* p, </div><div class="line">                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices); </div></div><!-- fragment --><p>Notice that this is a standalone function, not part of any class; <code>nvcc</code> does not play entirely nicely with device-side polymorphism, which is why we organise the code using a table of function pointers - a poor man’s implementation of the virtual-function lookups built into C++. Second, we need a pointer to the evaluation function:</p>
<div class="fragment"><div class="line">__device__ <a class="code" href="namespace_goo_fit.html#aa8f86c4fba93f7f349ee9cea3569a7c7">device_function_ptr</a> ptr_to_Gaussian = device_Gaussian; </div></div><!-- fragment --><p>where <code>device_function_ptr</code> is defined (using <code>typedef</code>) as a pointer to a function with the signature shown in the listing <a class="el" href="index.html#listingfsign">here</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="namespace_goo_fit.html#a6f9643fed3185c9bcdfb118b67bb1b16">fptype</a> (*<a class="code" href="namespace_goo_fit.html#aa8f86c4fba93f7f349ee9cea3569a7c7">device_function_ptr</a>) (<a class="code" href="namespace_goo_fit.html#a6f9643fed3185c9bcdfb118b67bb1b16">fptype</a>*, </div><div class="line">                                       fptype*, </div><div class="line">                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*);</div></div><!-- fragment --><p>This pointer (<a class="el" href="index.html#footnote4">4</a>) will be copied into the <code>device_function_table</code> array, and its index in that array is the PDF’s internal representation of “my evaluation function”.</p>
<p>Finally, the new PDF needs a bog-standard C++ class definition, extending the <code>GooPdf</code> superclass, which will allow it to be instantiated and passed around in user-level code. <a class="el" href="index.html#subindexarray">The indeces section</a> discusses what should happen in the constructor; otherwise the class may have any supporting paraphernalia that are necessary or useful to its evaluation - caches, lists of components, pointers to device-side constants, whatever.</p>
<h2><a class="anchor" id="subindexarray"></a>
The indices array </h2>
<p>The heart of a PDF’s organisation is its index array, which appears in the arguments to its device-side evaluation function as <code>unsigned int* indices</code>. The index array stores the position of the parameters of the PDF within the global parameter array; this allows different PDFs to share the same parameters, as in two Gaussians with a common mean. It also stores the position of the event variables, sometimes called observables, within the event array passed to the evaluation function; this is the argument <code>fptype* evt</code>.</p>
<p>The index array is created by the constructor of a PDF class; in particular, the constructor should call <code>registerParameter</code> so as to obtain the global indices of its parameters, store these numbers in a <code>vector&lt;unsigned int&gt;</code> (conventionally called <code>pindices</code>), and pass this <code>vector</code> to <code>initialize</code>. The PDF constructor should also call <code>registerObservable</code> on each of the event variables it depends on.</p>
<p>The <code>initialize</code> method constructs the array that is used on the GPU side, which consists of four parts. First is stored the number of parameters, which is equal to the size of the <code>pindices vector</code>. Next come the indices of the parameters, in the order they were put into <code>pindices</code>. Then comes the number of observables, and finally the indices of the observables, again in the order they were registered.</p>
<p>An example may be useful at this point. Consider the simple Gaussian PDF constructor:</p>
<div class="fragment"><div class="line">GaussianPdf::GaussianPdf (std::string n, </div><div class="line">                          Variable* _x, </div><div class="line">                          Variable* mean, </div><div class="line">                          Variable* sigma) </div><div class="line">  : GooPdf(_x, n) </div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; pindices;</div><div class="line">  pindices.push_back(registerParameter(mean));</div><div class="line">  pindices.push_back(registerParameter(sigma));</div><div class="line">  MEMCPY_FROM_SYMBOL((<span class="keywordtype">void</span>**) &amp;<a class="code" href="namespace_goo_fit.html#a629dda1cf456a097fd7834dd96f5ba71">host_fcn_ptr</a>, </div><div class="line">                       ptr_to_Gaussian, </div><div class="line">                       <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));</div><div class="line">  initialize(pindices); </div><div class="line">}</div></div><!-- fragment --><p>This is almost the simplest possible PDF: Two parameters, one observable, no messing about! Notice that the call to <code>registerObservable</code> is done in the parent <code>GooPdf</code> constructor - this saves some boilerplate in the constructors of one-observable PDFs. For the second and subsequent observables the calls should be done manually. The device-side index array for the Gaussian, assuming it is the only PDF in the system, looks like this: </p><pre class="fragment">index  0 1 2 3 4
value  2 0 1 1 0
</pre><p>Here the initial 2 is the number of parameters - mean and sigma. Then come their respective indices; since by assumption the Gaussian is the only PDF we’re constructing, these will simply be 0 and 1. Then comes the number of observables, which is 1, and finally the index of the observable - which, as it is the only observable registered, must be 0. Now we can consider how the device-side code makes use of this:</p>
<div class="fragment"><div class="line">__device__ fptype device_Gaussian (fptype* evt, </div><div class="line">                                   fptype* p, </div><div class="line">                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices) {</div><div class="line">  fptype x = evt[indices[2 + indices[0]]]; </div><div class="line">  fptype mean = p[indices[1]];</div><div class="line">  fptype sigma = p[indices[2]];</div><div class="line"></div><div class="line">  fptype ret = exp(-0.5*(x-mean)*(x-mean)/(sigma*sigma));</div><div class="line">  <span class="keywordflow">return</span> ret; </div><div class="line">}</div></div><!-- fragment --><p>The calculation of the Gaussian is straightforward enough, but let’s look at where the numbers <code>mean, sigma</code> and especially <code>x</code> come from. The function is passed a pointer to the particular event it is to calculate the value for, a global parameter array, and the index array. The parameter array, in the case of a single Gaussian, consists simply of the values for the mean and sigma in the current MINUIT iteration. Let us replace the index lookups in those lines with their values from above:</p>
<div class="fragment"><div class="line">fptype mean = p[0];</div><div class="line">fptype sigma = p[1]; </div></div><!-- fragment --><p>which is exactly what we want. The fetching of <code>x</code> appears a little more formidable, with its double <code>indices</code> lookup; it calls for some explanation. First, <code>indices[0]</code> is the number of parameters of the function; we want to skip ahead by this number to get to the ‘event’ part of the array. In the Gaussian, this is known at compile-time to be 2, but not every PDF writer is so fortunate; a polynomial PDF, for example, could have an arbitrary number of parameters. (Or it might specify a maximum number, say 10, and in most cases leave seven or eight of them fixed at zero - but then there would be a lot of wasted multiplications-by-zero and additions-of-zero.) Thus, as a convention, lookups of event variables should always use <code>indices[0]</code> even if the coder knows what that number is going to be. Then, 2 must be added to this number to account for the space taken by the number-of-parameters and number-of-observables entries in the array. So, replacing the first level of lookup by the values, we have:</p>
<div class="fragment"><div class="line">fptype x = evt[indices[4]]; </div></div><!-- fragment --><p>and <code>indices[4]</code> is just 0; so in other words, <code>x</code> is the first observable in the event. In the case of the single Gaussian, it is also the <em>only</em> observable, so we’ve done quite a bit of work to arrive at a zero that we knew from the start; but in more complex fits this would not be true. The <code>x</code> variable could be observable number 5, for all we know to the contrary in the general case. Likewise the mean and sigma could be stored at positions 80 and 101 of the global parameter array.</p>
<h2>Constants </h2>
<p>There are two ways of storing constants, or three if we count registering a <code>Variable</code> as a parameter and telling MINUIT to keep it fixed. For integer constants, we may simply store them in the index array; since it is up to the programmer to interpret the indices, there is no rule that says it absolutely must be taken as an offset into the global parameter array! An index can also store integers for any other purpose - the maximum degree of a polynomial, flagging the use of an optional parameter, or anything else you can think of. Indeed, this is exactly what the framework does in enforcing the convention that the first number in the index array is the number of parameters.</p>
<p>However, this will not serve for non-integer-valued constants. They must either go through MINUIT as fixed parameters, or else go into the <code>functorConstants</code> array. <code>functorConstants</code> works just like the global parameters array, except that it does not update on every MINUIT iteration since it is meant for storing constants. To use it, you should first reserve some space in it using the <code>registerConstants</code> method, which takes the number of constants you want as an argument and returns the index of the first one. Usually you will want to put that index in the <code>pindices</code> array. For example, suppose I want to store \(\sqrt{2\pi}\) as a constant for use in the Gaussian. Then I would modify the constructor thus:</p>
<div class="fragment"><div class="line">__host__ GaussianPdf::GaussianPdf (std::string n, </div><div class="line">                                   Variable* _x, </div><div class="line">                                   Variable* mean, </div><div class="line">                                   Variable* sigma) </div><div class="line">  : GooPdf(_x, n) </div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; pindices;</div><div class="line">  pindices.push_back(registerParameter(mean));</div><div class="line">  pindices.push_back(registerParameter(sigma));</div><div class="line"></div><div class="line">  pindices.push_back(registerConstants(1)); </div><div class="line">  fptype sqrt2pi = sqrt(2*M_PI);</div><div class="line">  MEMCPY_TO_SYMBOL(functorConstants, &amp;sqrt2pi, <span class="keyword">sizeof</span>(fptype), </div><div class="line">                     cIndex*<span class="keyword">sizeof</span>(fptype), cudaMemcpyHostToDevice); </div><div class="line"></div><div class="line">  MEMCPY_FROM_SYMBOL((<span class="keywordtype">void</span>**) &amp;<a class="code" href="namespace_goo_fit.html#a629dda1cf456a097fd7834dd96f5ba71">host_fcn_ptr</a>, ptr_to_Gaussian, <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));</div><div class="line">  initialize(pindices); </div><div class="line">}</div></div><!-- fragment --><p>Notice the member variable <code>cIndex</code>, which is set (and returned) by <code>registerConstants</code>; it is the index of the first constant belonging to this object. To extract my constant for use in the device function, I look it up as though it were a parameter, but the target array is <code>functorConstants</code> instead of the passed-in <code>p</code>:</p>
<div class="fragment"><div class="line">__device__ fptype device_Gaussian (fptype* evt, </div><div class="line">                                   fptype* p, </div><div class="line">                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices) {</div><div class="line">  fptype x = evt[indices[2 + indices[0]]]; </div><div class="line">  fptype mean = p[indices[1]];</div><div class="line">  fptype sigma = p[indices[2]];</div><div class="line">  fptype sqrt2pi = functorConstants[indices[3]];</div><div class="line"></div><div class="line">  fptype ret = exp(-0.5*(x-mean)*(x-mean)/(sigma*sigma));</div><div class="line">  ret /= sqrt2pi; </div><div class="line">  <span class="keywordflow">return</span> ret; </div><div class="line">}</div></div><!-- fragment --><p>If I had registered two constants instead of one, the second one would be looked up by <code>functorConstants[indices[3] + 1]</code>, not the <code>functorConstants[indices[4]]</code> one might naively expect. This is because the constant is stored next to the first one registered, but its <em>index</em> is not stored at all; it has to be calculated from the index of the first constant. Thus the <code>+1</code> must go outside the indices lookup, not inside it! Keeping the levels of indirection straight when constructing this sort of code calls for some care and attention.</p>
<p>Note that <code>functorConstants[0]</code> is reserved for the number of events in the fit.</p>
<h1><a class="anchor" id="engine"></a>
Program flow </h1>
<p>This section narrates the course of a fit after it is created, passing through MINUIT and the core <a class="el" href="namespace_goo_fit.html">GooFit</a> engine. In particular, we will consider the example Gaussian fit shown in listing <a class="el" href="index.html#listinggaussfit">Gauss fit</a> and look at what happens in these innocent-looking lines:</p>
<h2><a class="anchor" id="listingactualfit"></a>
Data transfer and fit invocation</h2>
<div class="fragment"><div class="line">gauss.setData(&amp;data);</div><div class="line"><a class="code" href="namespace_goo_fit.html#a70f7cd945b885cb3e7fe175e45e3b668">FitManager</a> fitter(&amp;gauss); </div><div class="line">fitter.fit(); </div></div><!-- fragment --><h2>Copying data </h2>
<p>The <code>setData</code> method copies the contents of the supplied <code>DataSet</code> to the GPU:</p>
<h2><a class="anchor" id="listingsetData"></a>
Internals of the setData method </h2>
<div class="fragment"><div class="line">setIndices();</div><div class="line"><span class="keywordtype">int</span> dimensions = observables.size();</div><div class="line">numEntries = data-&gt;getNumEvents(); </div><div class="line">numEvents = numEntries; </div><div class="line"></div><div class="line">fptype* host_array = <span class="keyword">new</span> fptype[numEntries*dimensions];</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numEntries; ++i) {</div><div class="line">  <span class="keywordflow">for</span> (obsIter v = obsBegin(); v != obsEnd(); ++v) {</div><div class="line">    fptype currVal = data-&gt;getValue((*v), i);</div><div class="line">    host_array[i*dimensions + (*v)-&gt;index] = currVal; </div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="namespace_goo_fit.html#af2bcb27f8446f3950037de6ce8681ee1">gooMalloc</a>((<span class="keywordtype">void</span>**) &amp;<a class="code" href="namespace_goo_fit.html#a4ad01ef84a1703f19e96a2eb711cf455">dev_event_array</a>, dimensions*numEntries*<span class="keyword">sizeof</span>(fptype)); </div><div class="line">cudaMemcpy(dev_event_array, host_array, dimensions*numEntries*<span class="keyword">sizeof</span>(fptype), cudaMemcpyHostToDevice);</div><div class="line">MEMCPY_TO_SYMBOL(functorConstants, &amp;numEvents, <span class="keyword">sizeof</span>(fptype), 0, cudaMemcpyHostToDevice); </div><div class="line"><span class="keyword">delete</span>[] host_array; </div></div><!-- fragment --><p>Notice the call to <code>setIndices</code>; this is where the indices of observables passed to the PDF are decided and copied into the indices array. This step cannot be done before all the subcomponents of the PDF have had a chance to register their observables. Hence <code>setData</code> should be called only after the creation of all PDF components, and only on the top-level PDF.</p>
<p>The array thus created has the simple structure <code>x1 y1 z1 x2 y2 z2 ... xN yN zN</code>, that is, the events are laid out contiguously in memory, each event consisting simply of the observables, in the same order every time. Notice that if the <code>DataSet</code> contains <code>Variable</code>s that have not been registered as observables, they are ignored. If <code>setData</code> is called with an <code>BinnedDataSet</code> object, the procedure is similar except that each ‘event’ consists of the coordinates of the bin center, the number of events in the bin, and either the bin error or the bin size. We will see later how the engine uses the <code>dev_event_array</code> either as a list of events or a list of bins.</p>
<h2>MINUIT setup </h2>
<p>Having copied the data to the GPU, the next task is to create the MINUIT object that will do the actual fit; this is done by creating a <code>FitManager</code> object, with the top-level PDF as its argument, and calling its <code>fit</code> method. The <code>fit</code> method does two things: First it calls the <code>getParameters</code> method of the supplied PDF, which recursively gets the registered parameters of all the component PDFs, and from the resulting list of <code>Variable</code>s it creates MINUIT parameters by calling <code>DefineParameter</code>. Second, it sets the method <code>FitFun</code> to be MINUIT’s function-to-minimise, and calls MINUIT’s <code>mnmigr</code> method.</p>
<p>A few variants on the above procedure exist. Most obviously, <a class="el" href="namespace_r_o_o_t.html">ROOT</a> contains three implementations of the MINUIT algorithm, named <code>TMinuit</code>, <code>TMinuit2</code>, and <code>TVirtualFitter</code> (<a class="el" href="index.html#footnote5">5</a>). One can switch between these by setting the constant <code>MINUIT_VERSION</code> in FitManager.hh to, respectively, 1, 2, and 3. The interfaces differ, but the essential procedure is the one described above: Define parameters, set function-to-minimise, run MIGRAD. (NB: As of v0.2, <a class="el" href="namespace_goo_fit.html">GooFit</a> has not recently been tested with <code>MINUIT_VERSION</code> set to 2 or 3.) In the case of <code>TMinuit</code>, one can call <code>setMaxCalls</code> to override the usual MINUIT limitation on the number of iterations, although my experience is that this is not usually helpful because running into the iteration limit tends to indicate a deeper problem with the fit. Finally, the underlying <code>TMinuit</code> object is available through the <code>getMinuitObject</code> method, allowing fine-grained control of what MINUIT does, for example by calling <code>mnhess</code> in place of <code>mnmigr</code>.</p>
<h2>PDF evaluation </h2>
<p>We have copied the data to the GPU, set up MINUIT, and invoked <code>mnmigr</code>. Program flow now passes to MINUIT, which for purposes of this documentation is a black box, for some time; it returns to <a class="el" href="namespace_goo_fit.html">GooFit</a> by calling the <code>FitFun</code> method with a list of parameters for which MINUIT would like us to evaluate the NLL. <code>FitFun</code> translates MINUIT indices into <a class="el" href="namespace_goo_fit.html">GooFit</a> indices, and calls <code>copyParams</code>, which eponymously copies the parameter array to <code>cudaArray</code> on the GPU. <code>FitFun</code> then returns the value from <code>GooPdf::calculateNLL</code> to MINUIT, which absorbs the number into its inner workings and eventually comes back with another set of parameters to be evaluated. Control continues to pass back and forth in this way until MINUIT converges or gives up, or until <a class="el" href="namespace_goo_fit.html">GooFit</a> crashes.</p>
<p>The <code>calculateNLL</code> method does two things: First it calls the <code>normalize</code> function of the PDF, which in turn will usually recursively normalize the components; the results of the <code>normalize</code> call are copied into the <code>normalisationFactors</code> array on the GPU. Next it calls <code>sumOfNll</code> and returns the resulting value. Particular PDF implementations may override <code>sumOfNll</code>; most notably <code>AddPdf</code> does so in order to have the option of returning an ‘extended’ likelihood, with a term for the Poisson probability of the observed number of events in addition to the event probabilities.</p>
<p>The <code>normalize</code> method, by default, simply evaluates the PDF at a grid of points, returning the sum of all the values multiplied by the grid fineness - a primitive algorithm for numerical integration, but one which takes advantage of the GPU’s massive parallelisation. The fineness of the grid usually depends on the getNumBins` member of the observables; in the case of the example Gaussian fit in listing <a class="el" href="index.html#listinggaussfit">Gauss fit</a>, the PDF will be evaluated at 1000 points, evenly spaced between -5 and 5. However, this behaviour can be overridden by calling the <code>setIntegrationFineness</code> method of the PDF object, in which case the number of bins (in each observable) will be equal to the supplied fineness.</p>
<p>Stripped of complications, the essential part of the <code>normalize</code> function is a call to <code>transform_reduce</code>:</p>
<h2><a class="anchor" id="listingnormalisation"></a>
Normalisation code. </h2>
<div class="fragment"><div class="line">fptype dummy = 0; </div><div class="line"><span class="keyword">static</span> plus&lt;fptype&gt; cudaPlus;</div><div class="line">constant_iterator&lt;fptype*&gt; arrayAddress(normRanges); </div><div class="line">constant_iterator&lt;int&gt; eventSize(observables.size());</div><div class="line">counting_iterator&lt;int&gt; binIndex(0); </div><div class="line"></div><div class="line">fptype sum = <a class="code" href="_thrust_override_8h.html#a5dd7e03e1d7dcd391fcfdb6397b3fd9a">transform_reduce</a>(make_zip_iterator(</div><div class="line">                               make_tuple(binIndex, </div><div class="line">                                          eventSize, </div><div class="line">                                          arrayAddress)),</div><div class="line">                              make_zip_iterator(</div><div class="line">                               make_tuple(binIndex + totalBins, </div><div class="line">                                          eventSize, </div><div class="line">                                          arrayAddress)),</div><div class="line">              *logger, dummy, cudaPlus); </div></div><!-- fragment --><p>Here <code>normRanges</code> is an array of triplets <code>lower, upper, bins</code> for each observable, created by the <code>generateNormRanges</code> method. The member <code>logger</code> points to an instance of the <code>MetricTaker</code> class, which has an operator method that Thrust will invoke on each bin index between the initial value of zero and the final value of <code>totalBins-1</code>. This operator method, which is invoked once per thread with a separate (global) bin number for each invocation, calculates the bin center and returns the value of the PDF at that point. The <code>dummy</code> and <code>cudaPlus</code> variables merely indicate that Thrust should add (rather than, say, multiply) all the returned values, and that it should start the sum at zero. The <code>normalisation</code> method returns this sum, but stores its inverse in the <code>host_normalisation</code> array that will eventually be copied to <code>normalisationFactors</code> on the GPU; this is to allow the micro-optimisation of multiplying by the inverse rather than dividing in every thread.</p>
<p>PDF implementations may override the <code>normalisation</code> method, and among the default PDFs, both <code>AddPdf</code> and <code>ProdPdf</code> do so to ensure that their components are correctly normalized. Among the more specialised implementations, <code>TddpPdf</code> overrides <code>normalize</code> so that it may cache the slowly-changing Breit-Wigner calculations, and also because its time dependence is analytically integrable and it is a good optimisation to do only the Dalitz-plot part numerically. This points to a more general rule, that once a PDF depends on three or four observables, the relatively primitive numerical integration outlined above may become unmanageable because of the number of points it creates. Finally, note that PDFs may, without overriding <code>normalize</code>, advertise an analytical integral by overriding <code>GooPdf</code>’s <code>hasAnalyticIntegral</code> method to return <code>true</code>, and then implementing an <code>integrate</code> method to be evaluated on the CPU.</p>
<p>The <code>logger</code> object will appear again in the actual PDF evaluation, performing a very similar function, so it is worth taking a moment to consider in detail exactly what the <code>transform_reduce</code> call does. The first two parameters (involving <code>make_tuple</code> calls) define the range of evaluation: In this case, global bins (<a class="el" href="index.html#footnote6">6</a>) 0 through \(N-1\). They also specify which <code>operator</code> method of <code>MetricTaker</code> should be called: It is the one which takes as arguments two integers (the bin index and event size) and an <code>fptype</code> array (holding the <code>normRanges</code> values), in that order. Conceptually, Thrust will create one thread for each unique value of the iterator range thus created - that is, one per global bin - and have each thread invoke the indicated <code>operator</code> method. As a matter of organisation on the physical chip, it is likely that Thrust will actually create a thousand or so threads and have each thread evaluate as many bins as needed; but at any rate, the <code>operator(int, int, fptype*)</code> method will be called once per global bin. The last two arguments indicate that the return value should be calculated as the sum of the return values from each <code>operator</code> invocation, and that the sum should start at zero. Finally, the <code>*logger</code> argument indicates the specific <code>MetricTaker</code> object to use, which is important because this is where the function-pointer and parameter indices are stored.</p>
<p>The <code>operator</code> does two things: First it calculates the bin centers, in each observable, of the global bin:</p>
<h2><a class="anchor" id="listingbincenter"></a>
Bin-center calculation </h2>
<div class="fragment"><div class="line">__shared__ fptype binCenters[1024*MAX_NUM_OBSERVABLES];</div><div class="line"></div><div class="line"><span class="comment">// To convert global bin number to (x,y,z...) coordinates: </span></div><div class="line"><span class="comment">// For each dimension, take the mod with the number of bins </span></div><div class="line"><span class="comment">// in that dimension. Then divide by the number of bins, in </span></div><div class="line"><span class="comment">// effect collapsing so the grid has one fewer dimension. </span></div><div class="line"><span class="comment">// Rinse and repeat. </span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> offset = threadIdx.x*MAX_NUM_OBSERVABLES;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices = paramIndices + parameters;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; evtSize; ++i) {</div><div class="line">  fptype lowerBound = thrust::get&lt;2&gt;(t)[3*i+0];</div><div class="line">  fptype upperBound = thrust::get&lt;2&gt;(t)[3*i+1];</div><div class="line">  <span class="keywordtype">int</span> numBins    = (int) floor(thrust::get&lt;2&gt;(t)[3*i+2] + 0.5); </div><div class="line">  <span class="keywordtype">int</span> localBin = binNumber % numBins;</div><div class="line"></div><div class="line">  fptype x = upperBound - lowerBound; </div><div class="line">  x /= numBins;</div><div class="line">  x *= (localBin + 0.5); </div><div class="line">  x += lowerBound;</div><div class="line">  binCenters[indices[indices[0] + 2 + i]+offset] = x; </div><div class="line">  binNumber /= numBins;</div><div class="line">}</div></div><!-- fragment --><p>in the straightforward way, and stores the bin centers in a <em>fake event</em>. Since events are just lists of observables, all that’s necessary is to keep track of which part of the <code>__shared__</code> (<a class="el" href="index.html#footnote7">7</a>) <code>binCenters</code> array is owned by this thread, look up the index-within-events of each observable, and set the entries of the locally-owned part of <code>binCenters</code> accordingly. This fake event is then sent to the PDF for evaluation:</p>
<div class="fragment"><div class="line">fptype ret = <a class="code" href="namespace_goo_fit.html#a87a68afb2dc5f613178ac1dea8a9955f">callFunction</a>(binCenters+offset, </div><div class="line">                          functionIdx, </div><div class="line">                          parameters); </div></div><!-- fragment --><p>where <code>callFunction</code> is just a wrapper for looking up the function referred to by <code>functionIdx</code> and calling it with the right part of the parameter array:</p>
<h2><a class="anchor" id="listingcallfunction"></a>
Code to call device-side PDF implementations (some lines broken up for clarity) </h2>
<div class="fragment"><div class="line">__device__ fptype <a class="code" href="namespace_goo_fit.html#a87a68afb2dc5f613178ac1dea8a9955f">callFunction</a> (fptype* eventAddress, </div><div class="line">                                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> functionIdx, </div><div class="line">                                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> paramIdx) {</div><div class="line">  <span class="keywordtype">void</span>* rawPtr = device_function_table[functionIdx];</div><div class="line">  <a class="code" href="namespace_goo_fit.html#aa8f86c4fba93f7f349ee9cea3569a7c7">device_function_ptr</a> fcn;</div><div class="line">  fcn = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="namespace_goo_fit.html#aa8f86c4fba93f7f349ee9cea3569a7c7">device_function_ptr</a><span class="keyword">&gt;</span>(rawPtr);</div><div class="line">  <span class="keywordflow">return</span> (*fcn)(eventAddress, </div><div class="line">                cudaArray, </div><div class="line">                paramIndices + paramIdx);</div><div class="line">}</div></div><!-- fragment --><p>This, finally, is where the <code>__device__</code> function from the PDF definitions in section <a class="el" href="index.html#newpdfs">New PDFs</a> is called; we have now connected all this engine code with the evaluation code for the Gaussian, Breit-Wigner, polynomial, sum of functions, or whatever calculation we happen to be doing today.</p>
<p>Having found the integral of the PDF, either using fake events as outlined above or with an analytic calculation, we are now ready to find the actual NLL, or sum of chi-squares, or other goodness-of-fit metric, using the actual, observed events that we copied across in <code>setData</code>. The procedure is similar to that for the normalisation:</p>
<h2><a class="anchor" id="listingnlleval"></a>
Goodness-of-fit evaluation </h2>
<div class="fragment"><div class="line"><a class="code" href="_thrust_override_8h.html#a5dd7e03e1d7dcd391fcfdb6397b3fd9a">transform_reduce</a>(make_zip_iterator(make_tuple(eventIndex, </div><div class="line">                                              arrayAddress, </div><div class="line">                                              eventSize)),</div><div class="line">                 make_zip_iterator(make_tuple(eventIndex + numEntries, </div><div class="line">                                              arrayAddress, </div><div class="line">                                              eventSize)),</div><div class="line">                 *logger, dummy, cudaPlus);   </div></div><!-- fragment --><p>Here the <code>*logger</code>, <code>dummy</code>, and <code>cudaPlus</code> arguments are doing the same jobs as before. The tuple arguments, however, differ: In particular, they are now indicating the range 0 to \(N-1\) in <em>events</em>, not bins, and <code>arrayAddress</code> this time points to the array of events, not to a set of normalisation triplets from which bin centers can be calculated. Since the order of the arguments differs - it is now <code>int, fptype*, int</code> - a different <code>operator</code> method is called:</p>
<h2><a class="anchor" id="listingmaineval"></a>
Main evaluation operator (some lines broken up for clarity) </h2>
<div class="fragment"><div class="line">__device__ fptype MetricTaker::operator () </div><div class="line">  (thrust::tuple&lt;int, fptype*, int&gt; t) <span class="keyword">const</span> {</div><div class="line">  <span class="comment">// Calculate event offset for this thread. </span></div><div class="line">  <span class="keywordtype">int</span> eventIndex = thrust::get&lt;0&gt;(t);</div><div class="line">  <span class="keywordtype">int</span> eventSize  = thrust::get&lt;2&gt;(t);</div><div class="line">  fptype* eventAddress = thrust::get&lt;1&gt;(t);</div><div class="line">  eventAddress += (eventIndex * abs(eventSize)); </div><div class="line"></div><div class="line">  <span class="comment">// Causes stack size to be statically undeterminable.</span></div><div class="line">  fptype ret = <a class="code" href="namespace_goo_fit.html#a87a68afb2dc5f613178ac1dea8a9955f">callFunction</a>(eventAddress, functionIdx, parameters);</div><div class="line"></div><div class="line">  <span class="comment">// Notice assumption here! For unbinned fits the </span></div><div class="line">  <span class="comment">// eventAddress pointer won&#39;t be used in the metric, </span></div><div class="line">  <span class="comment">// so it doesn&#39;t matter what it is. For binned fits it </span></div><div class="line">  <span class="comment">// is assumed that the structure of the event is </span></div><div class="line">  <span class="comment">// (obs1 obs2... binentry binvolume), so that the array</span></div><div class="line">  <span class="comment">// passed to the metric consists of (binentry binvolume). </span></div><div class="line">  <span class="keywordtype">void</span>* fcnAddr = device_function_table[metricIndex];</div><div class="line">  <a class="code" href="namespace_goo_fit.html#a7ed84a17159e8a1112cffd0cd4b77c20">device_metric_ptr</a> fcnPtr;</div><div class="line">  fcnPtr = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="namespace_goo_fit.html#a7ed84a17159e8a1112cffd0cd4b77c20">device_metric_ptr</a><span class="keyword">&gt;</span>(fcnAddr);</div><div class="line">  eventAddress += abs(eventSize)-2;</div><div class="line">  ret = (*fcnPtr)(ret, eventAddress, parameters);</div><div class="line">  <span class="keywordflow">return</span> ret; </div><div class="line">}</div></div><!-- fragment --><p>Observe that, for binned events, <code>eventSize</code> is negative; in this case the event array looks like <code>x1 y1 n1 v1 x2 y2 n2 v2 ... xN yN nN vN</code> where <code>x</code> and <code>y</code> are bin centers, <code>n</code> is the number of entries, and <code>v</code> is the bin volume or error. This does not matter for the PDF evaluation invoked by <code>callFunction</code>, which will just get a pointer to the start of the event and read off the bin centers as event variables; hence the <code>abs(eventSize)</code> in the calculation of the event address allows binned and unbinned PDFs to be treated the same. However, it very much does matter for the goodness-of-fit metric. Suppose the fit is the default NLL: Then all the operator needs to do at this point is take the logarithm of what the PDF returned, multiply by -2, and be on its way. But if it is a chi-square fit, then it must calculate the expected number of hits in the bin, which depends on the PDF value, the bin volume, and the total number of events (<a class="el" href="index.html#footnote8">8</a>), subtract the observed number, square, and divide by the observed number. Hence there is a second function-pointer lookup, but now the <code>void*</code> stored in <code>device_function_table</code> is to be interpreted as a different kind of function - a “take the metric” function rather than a “calculate the PDF” function. The <code>metricIndex</code> member of <code>MetricTaker</code> is set by the <code>FitControl</code> object of the PDF; it points to one of the <code>calculateFoo</code> functions:</p>
<h2><a class="anchor" id="listingmetrics"></a>
Metric-taking functions </h2>
<div class="fragment"><div class="line">__device__ fptype calculateEval (fptype rawPdf, </div><div class="line">                                 fptype* evtVal, </div><div class="line">                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> par) {</div><div class="line">  <span class="comment">// Just return the raw PDF value, for use </span></div><div class="line">  <span class="comment">// in (eg) normalisation. </span></div><div class="line">  <span class="keywordflow">return</span> rawPdf; </div><div class="line">}</div><div class="line"></div><div class="line">__device__ fptype calculateNLL (fptype rawPdf, </div><div class="line">                                 fptype* evtVal, </div><div class="line">                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> par) {</div><div class="line">  rawPdf *= normalisationFactors[par];</div><div class="line">  <span class="keywordflow">return</span> rawPdf &gt; 0 ? -log(rawPdf) : 0; </div><div class="line">}</div><div class="line"></div><div class="line">__device__ fptype calculateProb (fptype rawPdf, </div><div class="line">                                 fptype* evtVal, </div><div class="line">                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> par) {</div><div class="line">  <span class="comment">// Return probability, ie normalized PDF value.</span></div><div class="line">  <span class="keywordflow">return</span> rawPdf * normalisationFactors[par];</div><div class="line">}</div><div class="line"></div><div class="line">__device__ fptype calculateBinAvg (fptype rawPdf, </div><div class="line">                                 fptype* evtVal, </div><div class="line">                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> par) {</div><div class="line">  rawPdf *= normalisationFactors[par];</div><div class="line">  rawPdf *= evtVal[1]; <span class="comment">// Bin volume </span></div><div class="line">  <span class="comment">// Log-likelihood of numEvents with expectation of exp </span></div><div class="line">  <span class="comment">// is (-exp + numEvents*ln(exp) - ln(numEvents!)). </span></div><div class="line">  <span class="comment">// The last is constant, so we drop it; and then multiply </span></div><div class="line">  <span class="comment">// by minus one to get the negative log-likelihood. </span></div><div class="line">  <span class="keywordflow">if</span> (rawPdf &gt; 0) {</div><div class="line">    fptype expEvents = functorConstants[0]*rawPdf;</div><div class="line">    <span class="keywordflow">return</span> (expEvents - evtVal[0]*log(expEvents)); </div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0; </div><div class="line">}</div><div class="line"></div><div class="line">__device__ fptype calculateBinWithError (fptype rawPdf, </div><div class="line">                                 fptype* evtVal, </div><div class="line">                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> par) {</div><div class="line">  <span class="comment">// In this case interpret the rawPdf as just a number, </span></div><div class="line">  <span class="comment">// not a number of events. Do not divide by integral over </span></div><div class="line">  <span class="comment">// phase space, do not multiply by bin volume, and do not </span></div><div class="line">  <span class="comment">// collect 200 dollars. evtVal should have the structure </span></div><div class="line">  <span class="comment">// (bin entry, bin error). </span></div><div class="line">  rawPdf -= evtVal[0]; <span class="comment">// Subtract observed value.</span></div><div class="line">  rawPdf /= evtVal[1]; <span class="comment">// Divide by error.</span></div><div class="line">  rawPdf *= rawPdf; </div><div class="line">  <span class="keywordflow">return</span> rawPdf; </div><div class="line">}</div><div class="line"></div><div class="line">__device__ fptype calculateChisq (fptype rawPdf, </div><div class="line">                                 fptype* evtVal, </div><div class="line">                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> par) {</div><div class="line">  rawPdf *= normalisationFactors[par];</div><div class="line">  rawPdf *= evtVal[1]; <span class="comment">// Bin volume </span></div><div class="line"></div><div class="line">  fptype ret = <a class="code" href="_global_cuda_defines_8h.html#a3282a5cfe39f52044508cb8d8e62b9df">pow</a>(rawPdf * functorConstants[0] - evtVal[0], 2);</div><div class="line">  ret /= (evtVal[0] &gt; 1 ? evtVal[0] : 1); </div><div class="line">  <span class="keywordflow">return</span> ret;</div><div class="line">}</div></div><!-- fragment --><p>Notice the use of <code>normalisationFactors</code> in most of the metric functions, and the special cases when the PDF or the observed number of events is zero.</p>
<p>It is worth noting that the PDF evaluation function may itself call other functions, either using <code>callFunction</code> or manually casting a function index into other kinds of functions, as in the metric calculation of listing <a class="el" href="index.html#listingmaineval">Main Eval</a>. For example, in <code>DalitzPlotPdf</code>, each resonance may be parametrised by a relativistic Breit-Wigner, a Gaussian, a Flatte function, or more esoteric forms; so the main function is supplied with a list of function indices and parameter indices for them, and interprets the <code>void</code> pointer from <code>device_function_table</code> as a specialised function type taking Dalitz-plot location (rather than a generic event) as its argument. More prosaically, <code>AddPdf</code> simply carries a list of PDF function indices and indices of weights to assign them, and invokes <code>callFunction</code> several times, multiplying the results by its weight parameters and returning the sum.</p>
<p>We have now calculated the function value that we ask MINUIT to minimise, for a single set of parameters; this value is passed back to MINUIT, which does its thing and comes up with another set of parameters for us, completing the loop. Ends here the saga of the fit iteration; you now know the entire essential functionality of GooFit’s core engine.</p>
<h1>Existing PDF classes </h1>
<p>The <a class="el" href="namespace_goo_fit.html">GooFit</a> PDFs, like ancient Gaul, are roughly divisible into three:</p>
<ul>
<li>Basic functions, written because they are (expected to be) frequently used, such as the Gaussian and polynomial PDFs.</li>
<li>Combiners, functions that take other functions as arguments and spit out some combination of the inputs, for example sums and products.</li>
<li>Specialised PDFs, written for the \(D^0\to\pi\pi\pi^0\) mixing analysis that is the driving test case for GooFit’s capabilities.</li>
</ul>
<p>In the lists below, note that all the constructors take pointers to <code>Variable</code> objects; rather than repetitively repeat “<code>Variable</code> pointer” in a redundantly recurring manner, we just say <code>Variable</code>. Additionally, the first argument in every constructor is the name of the object being created; again this is not mentioned in every item. By convention, constructors take observables first, then parameters.</p>
<h2>Basic PDFs </h2>
<p>Basic PDFs are relatively straightforward: They take one or more observables and one or more parameters, and implement operations that are in some sense ‘atomic’ - they do not combine several functions in any way. Usually they have a reasonably well-known given name, for example “the threshold function” or “a polynomial”. The canonical example is the Gaussian PDF.</p>
<ul>
<li><code>ArgusPdf</code>: Implements a threshold function <p class="formulaDsp">
\begin{align} P(x;m_0,a,p) &amp;=&amp; \left\{ \begin{matrix} 0 &amp; x \le m_0 \\ x\left(\frac{x^2-m_0^2}{m_0^2}\right)^p e^{a\frac{x^2-m_0^2}{m_0^2}} &amp; x &gt; m_0 \\ \end{matrix} \right. \end{align}
</p>
 where the power \(p\) is, by default, fixed at 0.5. The constructor takes <code>Variable</code>s representing \(x\), \(m_0\), and \(a\), followed by a boolean indicating whether the threshold is an upper or lower bound. The equation above shows the PDF for a lower bound; for upper bounds, \(x^2-m_0^2\) becomes instead \(m_0^2-x^2\), and the value is zero above rather than below \(m_0\). The constructor also takes an optional <code>Variable</code> representing the power \(p\); if not given, a default parameter with value 0.5 is created.</li>
<li><code>BifurGaussPdf</code>: A two-sided Gaussian, with a \(\sigma\) that varies depending on which side of the mean you are on: <p class="formulaDsp">
\begin{align} P(x;m,\sigma_L,\sigma_R) &amp;=&amp; \left\{ \begin{matrix} e^{-\frac{(x-m)^2}{2\sigma_L^2}} &amp; x \le m \\ e^{-\frac{(x-m)^2}{2\sigma_R^2}} &amp; x &gt; m. \\ \end{matrix} \right. \end{align}
</p>
 The constructor takes the observable \(x\), mean \(m\), and left and right sigmas \(\sigma_{L,R}\).</li>
<li><code>BWPdf</code>: A non-relativistic Breit-Wigner function, sometimes called a Cauchy function: <p class="formulaDsp">
\begin{align} P(x;m,\Gamma) &amp;=&amp; \frac{1}{2\sqrt{\pi}}\frac{\Gamma}{(x-m)^2 + \Gamma^2/4} \end{align}
</p>
 The constructor takes the observable \(x\), mean \(m\), and width \(\Gamma\).</li>
<li><p class="startli"><code>CorrGaussianPdf</code>: A correlated Gaussian - that is, a function of two variables \(x\) and \(y\), each described by a Gaussian distribution, but the width of the \(y\) distribution depends on \(x\):</p>
<p class="formulaDsp">
\begin{align} P(x,y;\bar x,\sigma_x,\bar y, \sigma_y, k) &amp;=&amp; e^{-\frac{(x-\bar x)^2}{2\sigma_x^2}}e^{-\frac{(y-\bar y)^2}{2(1 + k(\frac{x-\bar x}{\sigma_x})^2)\sigma_y^2}} \end{align}
</p>
<p> In other words, the effective \(\sigma_y\) grows quadratically in the normalized distance from the mean of \(x\), with the quadratic term having coefficient \(k\). The constructor takes observables \(x\) and \(y\), means and widths \(\bar x\), \(\sigma_x\), \(\bar y\) and \(\sigma_y\), and coefficient \(k\). Notice that if \(k\) is zero, the function reduces to a product of two Gaussians, \(P(x,y;\bar x,\sigma_x,\bar y, \sigma_y) = G(x;\bar x, \sigma_x)G(y;\bar y, \sigma_y)\).</p>
</li>
<li><p class="startli"><code>CrystalBallPdf</code>: A Gaussian with a power-law tail on one side:</p>
<p class="formulaDsp">
\begin{align} P(x;m,\sigma,\alpha,p) &amp;=&amp; \left\{ \begin{matrix} e^{-\frac{(x-m)^2}{2\sigma^2}} &amp; \mathrm{sg}(\alpha)\frac{x - m}{\sigma} \le \mathrm{sg}(\alpha)\alpha \\ e^{-\alpha^2/2}\left(\frac{p/\alpha}{p/\alpha - \alpha + \frac{x-m}{\sigma}}\right)^p &amp; \mathrm{otherwise } (\alpha\ne 0). \\ \end{matrix} \right. \end{align}
</p>
<p> The constructor takes the observable \(x\), the mean \(m\), width \(\sigma\), cutoff \(\alpha\), and power \(p\). Note that if \(\alpha\) is negative, the power-law tail is on the right; if positive, on the left. For \(\alpha=0\), the function reduces to a simple Gaussian in order to avoid \(p/\alpha\) blowing up.</p>
</li>
<li><code>ExpGausPdf</code>: An exponential decay convolved with a Gaussian resolution: <p class="formulaDsp">
\begin{align} P(t;m,\sigma,\tau) &amp;=&amp; e^{-t/\tau} \otimes e^{-\frac{(t-m)^2}{2\sigma^2}} \\ &amp;=&amp; (\tau/2)e^{(\tau/2)(2m+\tau\sigma^2-2t}\mathrm{erfc}\left(\frac{m+\tau\sigma^2-t}{\sigma\sqrt{2}}\right) \end{align}
</p>
 where \(\mathrm{erfc}\) is the complementary error function. The constructor takes the observed time \(t\), mean \(m\) and width \(\sigma\) of the resolution, and lifetime \(\tau\). Note that the original decay function is zero for \(t&lt;0\).</li>
<li><code>ExpPdf</code>: A plain exponential, <p class="formulaDsp">
\begin{align} P(x;\alpha, x_0) &amp;=&amp; e^{\alpha(x-x_0)} \end{align}
</p>
 taking the observable \(x\), exponential constant \(\alpha\), and optional offset \(x_0\). If \(x_0\) is not specified it defaults to zero. A variant constructor takes, in place of \(\alpha\), a <code>vector</code> of coefficients (in the order \(\alpha_0\) to \(\alpha_n\)) to form a polynomial in the exponent: <p class="formulaDsp">
\begin{align} P(x;\alpha_0, \alpha_1, \ldots \alpha_n, x_0) &amp;=&amp; e^{\alpha_0 + \alpha_1(x-x_0) + \alpha_2(x-x_0)^2 + \ldots + \alpha_n(x-x_0)^n} \end{align}
</p>
 The offset \(x_0\) is again optional and defaults to zero.</li>
<li><code>GaussianPdf</code>: What can I say? It’s a normal distribution, the potato of PDFs. Kind of bland, but goes with anything. National cuisines have been based on it. <p class="formulaDsp">
\begin{align} P(x;m,\sigma) &amp;=&amp; e^-\frac{(x-m)^2}{2\sigma^2} \end{align}
</p>
 The constructor takes the observable \(x\), mean \(m\), and width \(\sigma\).</li>
<li><p class="startli"><code>InterHistPdf</code>: An interpolating histogram; in one dimension:</p>
<p class="formulaDsp">
\begin{align} P(x) &amp;=&amp; \frac{f(x, b(x))H[b(x)] + f(x, 1 + b(x))H[b(x) + 1]}{f(x, b(x)) + f(x, 1 + b(x))} \end{align}
</p>
<p> where \(H\) is a histogram, \(H[n]\) is the content of its bin with index \(n\), \(b(x)\) is a function that returns the bin number that \(x\) falls into, and \(f(x, n)\) is the distance between \(x\) and the center of bin \(n\). In other words, it does linear interpolation between bins. However, there are two complicating factors. First, the histogram may have up to ten (<a class="el" href="index.html#footnote9">9</a>) dimensions. Second, the dimensions may be either observables or fit parameters. So, for example, suppose we want to fit for the width \(\sigma\) of a Gaussian distribution, without using the potato of PDFs. We can do this by making a two-dimensional histogram: The \(x\) dimension is the observable, the \(y\) is \(\sigma\). Fill the histogram with the value of the Gaussian (<a class="el" href="index.html#footnote10">10</a>) at each \(x\) given the \(\sigma\) in that bin. Now when the fit asks the PDF, “What is your value at \(x\) given this \(\sigma\)?”, the PDF responds by interpolating linearly between four bins - ones that were precalculated with \(\sigma\) values close to what the fit is asking about. For the Gaussian this is rather un-necessary, but may save some time for computationally expensive functions.</p>
<p class="startli">The constructor takes a <code>BinnedDataSet</code> representing the underlying histogram, a <code>vector</code> of fit parameters, and a <code>vector</code> of observables.</p>
</li>
<li><code>JohnsonSUPdf</code>: Another modified Gaussian. You can eat potatoes a lot of different ways: <p class="formulaDsp">
\begin{align} P(x;m,\sigma,\gamma,\delta) &amp;=&amp; \frac{\delta}{\sigma\sqrt{2\pi(1+\frac{(x-m)^2}{\sigma^2})}} e^{-\frac{1}{2}\left(\gamma + \delta\log(\frac{x-m}{\sigma}+\sqrt{1+\frac{(x-m)^2}{\sigma^2}})\right)^2} \end{align}
</p>
 The constructor takes the observable \(x\), mean \(m\), width \(\sigma\), scale parameter \(\gamma\), and shape parameter \(\delta\).</li>
<li><p class="startli"><code>KinLimitBWPdf</code>: A relativistic Breit-Wigner function modified by a factor accounting for limited phase space (<a class="el" href="index.html#footnote11">11</a>); for example, in the decay \(D^{*+}\to D^0\pi^+\), the difference between the \(D^*\) and \(D^0\) masses is only slightly more than the pion mass. Consequently, the distribution of \(\Delta m = m(D^*) - m(D^0)\) is slightly asymmetric: The left side of the peak, where the phase space narrows rapidly, is less likely than the right side. </p><p class="formulaDsp">
\begin{align} P(x;x_0,\Gamma,M,m) &amp;=&amp; \left\{ \begin{matrix} 0 &amp; \lambda(x_0,M,m) \le 0 \\ \frac{S(x,x_0,M,m)x_0&#39;\Gamma^2}{\left(x_0&#39;-x&#39;^2\right)^2 + x_0&#39;\Gamma^2S^2(x,x_0,M,m)} &amp; \mathrm{otherwise.} \end{matrix} \right. \end{align}
</p>
<p> Here priming indicates addition of \(M\), so that \(x&#39;=x+M\), \(x_0&#39;=x_0+M\); the phase-space function \(S\) and its supporting characters \(\lambda\), \(p\), and \(b_W\) are given by</p>
<p class="formulaDsp">
\begin{align} S(x,x_0,M,m) &amp;=&amp; \left(\frac{p(x,M,m)}{p(x_0,M,m)}\right)^3\left(\frac{b_W(x,M,m)}{b_W(x_0,M,m)}\right)^2 \\ b_W(x,M,m) &amp;=&amp; \frac{1}{\sqrt{1 + r^2p^2(x,M,m)}}\\ p(x,M,m) &amp;=&amp; \sqrt{\lambda(x,M,m)/(2x)}\\ \lambda(x,M,m) &amp;=&amp; \left(x&#39;^2-(M-m)^2\right)\left(x&#39;^2-(M+m)^2\right). \end{align}
</p>
<p> The radius \(r\) that appears in \(b_W\) (which does not stand for Breit-Wigner, but Blatt-Weisskopf!) is hardcoded to be 1.6.</p>
<p class="startli">The constructor takes the observable \(x\), mean \(x_0\), and width \(\Gamma\). The large and small masses \(M\) and \(m\), which determine the phase space, are by default 1.8645 (the \(D^0\) mass) and 0.13957 (mass of a charged pion), but can be set with a call to <code>setMasses</code>. Note that they are constants, not fit parameters.</p>
</li>
<li><code>LandauPdf</code>: A shape with a long right-hand tail - so long, in fact, that its moments are not defined. If the most probable value (note that this is not a mean) and the width are taken as 0 and 1, the PDF is <p class="formulaDsp">
\begin{align} P(x) &amp;=&amp; \frac{1}{\pi}\int_0^\infty e^{-t\log t - xt}\sin(t\pi)\mathrm{d}t \end{align}
</p>
 but the <a class="el" href="namespace_goo_fit.html">GooFit</a> implementation is a lookup table stolen from CERNLIB. The constructor takes the observable \(x\), most probable value \(\mu\) (which shifts the above expression) and the width \(\sigma\) (which scales it).</li>
<li><code>NovosibirskPdf</code>: A custom shape with a long tail: <p class="formulaDsp">
\begin{align} P(x;m,\sigma,t) &amp;=&amp; e^{-\frac{1}{2}\left(\log^2(1+t\frac{x-m}{\sigma}\frac{\sinh(t\sqrt{\log(4)})}{\sqrt{\log(4)}})/t + t^2\right)} \end{align}
</p>
 The constructor takes the observable \(x\), mean \(m\), width \(\sigma\), and tail factor \(t\). If \(t\) is less than \(10^{-7}\), the function returns a simple Gaussian, which probably indicates that it approximates a Gaussian for small tail parameters, but I’d hate to have to show such a thing.</li>
<li><p class="startli"><code>PolynomialPdf</code>: If the Gaussian is the potato, what is the polynomial? Bread? Milk? Nothing exotic, at any rate. The <a class="el" href="namespace_goo_fit.html">GooFit</a> version does have some subtleties, to allow for polynomials over an arbitrary number (<a class="el" href="index.html#footnote12">12</a>) of dimensions: </p><p class="formulaDsp">
\begin{align} P(\vec x; \vec a, \vec x_0, N) &amp;=&amp; \sum\limits_{p_1+p_2+\ldots+p_n \le N} a_{p_1p_2\ldots p_n} \prod\limits_{i=1}^n (\vec x - \vec x_0)_i^{p_i} \end{align}
</p>
<p> where \(N\) is the highest degree of the polynomial and \(n\) is the number of dimensions. The constructor takes a <code>vector</code> of observables, denoted \(\vec x\) above; a <code>vector</code> of coefficients, \(\vec a\), a <code>vector</code> of optional offsets \(\vec x_0\) (if not specified, these default to zero), and the maximum degree \(N\). The coefficients are in the order \(a_{p_0p_0\ldots p_0}, a_{p_1p_0\ldots p_0}, \ldots a_{p_Np_0\ldots p_0}, a_{p_0p_1\ldots p_0}, a_{p_1p_1\ldots p_0}, \ldots a_{p_0p_0\ldots p_N}\). In other words, start at the index for the constant term, and increment the power of the leftmost observable. Every time the sum of the powers reaches \(N\), reset the leftmost power to zero and increment the next-leftmost. When the next-leftmost reaches \(N\), reset it to zero and increment the third-leftmost, and so on. An example may be helpful; for two dimensions \(x\) and \(y\), and a maximum power of 3, the order is \(a_{00}, a_{10}, a_{20}, a_{30}, a_{01}, a_{11}, a_{21}, a_{02}, a_{12}, a_{03}\). This can be visualised as picking boxes out of a matrix and discarding the ones where the powers exceed the maximum:</p>
<p class="formulaDsp">
\[ \begin{array}{cccc} 9: x^0y^3 &amp; - &amp; - &amp; - \\ 7: x^0y^2 &amp; 8: x^1y^2 &amp; - &amp; - \\ 4: x^0y^1 &amp; 5: x^1y^1 &amp; 6: x^2y^1 &amp; - \\ 0: x^0y^0 &amp; 1: x^1y^0 &amp; 2: x^2y^0 &amp; 3: x^3y^0 \\ \end{array} \]
</p>
<p> starting in the lower-lefthand corner and going right, then up.</p>
<p class="startli">There is also a simpler version of the constructor for the case of a polynomial with only one dimension; it takes the observable, a <code>vector</code> of coefficients, an optional offset, and the lowest (not highest) degree of the polynomial; the latter two both default to zero. In this case the order of the coefficients is from lowest to highest power.</p>
</li>
<li><p class="startli"><code>ScaledGaussianPdf</code>: Another Gaussian variant. This one moves its mean by a bias \(b\) and scales its width by a scale factor \(\epsilon\): </p><p class="formulaDsp">
\begin{align} P(x;m,\sigma,b,\epsilon) &amp;=&amp; e^{-\frac{(x+b-m)^2}{2(\sigma(1+\epsilon))^2}}. \end{align}
</p>
<p> This has a somewhat specialised function: It allows fitting Monte Carlo to, for example, a sum of two Gaussians, whose means and widths are then frozen. Then real data can be fit for a common bias and \(\epsilon\).</p>
<p class="startli">The constructor takes the observable \(x\), mean \(m\), width \(\sigma\), bias \(b\) and scale factor \(\epsilon\).</p>
</li>
<li><code>SmoothHistogramPdf</code>: Another histogram, but this one does smoothing in place of interpolation. That is, suppose the event falls in bin \(N\) of a one-dimensional histogram; then the returned value is a weighted average of bins \(N-1\), \(N\), and \(N+1\). For multidimensional cases the weighted average is over all the neighbouring bins, including diagonals: <p class="formulaDsp">
\begin{align} P(\vec x;s;H) &amp;=&amp; \frac{H(\mathrm{bin}(\vec x)) + s\sum\limits_{i=\mathrm{neighbours}}\delta{i}H(i)}{1 + s\sum\limits_{i=\mathrm{neighbours}}\delta{i}} \end{align}
</p>
 where \(\delta_i\) is zero for bins that fall outside the histogram limits, and one otherwise. The constructor takes the underlying histogram \(H\) (which also defines the event vector \(\vec x\)) and the smoothing factor \(s\); notice that if \(s\) is zero, the PDF reduces to a simple histogram lookup. The <code>BinnedDataSet</code> representing \(H\) may be empty; in that case the lookup table should be set later using the <code>copyHistogramToDevice</code> method.</li>
<li><code>StepPdf</code>: Also known as the Heaviside function. Zero up to a point, then 1 after that point: <p class="formulaDsp">
\begin{align} P(x;x_0) &amp;=&amp; \left\{ \begin{matrix} 0 &amp; x \le x_0 \\ 1 &amp; x &gt; x_0 \end{matrix} \right. \end{align}
</p>
 The constructor takes the observable \(x\) and threshold \(x_0\).</li>
<li><code>VoigtianPdf</code>: A convolution of a classical Breit-Wigner and a Gaussian resolution: <p class="formulaDsp">
\begin{align} P(x;m,\sigma,\Gamma) &amp;=&amp; \int\limits_{-\infty}^\infty\frac{\Gamma}{(t-m)^2-\Gamma^2/4} e^{-\frac{(t-x)^2}{2\sigma^2}}\mathrm{d}t. \end{align}
</p>
 The actual implementation is a horrible lookup-table-interpolation; had Lovecraft been aware of this sort of thing, he would not have piffled about writing about mere incomprehensible horrors from the depths of time. The constructor takes the observable \(x\), mean \(m\), Gaussian resolution width \(\sigma\), and Breit-Wigner width \(\Gamma\).</li>
</ul>
<h2>Combination PDFs </h2>
<p>These are the tools that allow <a class="el" href="namespace_goo_fit.html">GooFit</a> to be more than a collection of special cases. The most obvious example is a sum of PDFs - without a class for this, you’d have to write a new PDF every time you added a Gaussian to your fit.</p>
<ul>
<li><p class="startli"><code>AddPdf</code>: A weighted sum of two or more PDFs. There are two variants, ‘extended’ and ‘unextended’. In the extended version the weights are interpreted as numbers of events, and \(N\) PDFs have \(N\) weights; in the unextended version the weights are probabilities (i.e., between 0 and 1) and \(N\) PDFs have \(N-1\) weights, with the probability of the last PDF being 1 minus the sum of the weights of the others. </p><p class="formulaDsp">
\begin{align} P(F_1,\ldots, F_n,w_1,\ldots,w_n) &amp;=&amp; w_1F_1 + \ldots + w_nF_n \\ P(F_1,\ldots, F_n,w_1,\ldots,w_{n-1}) &amp;=&amp; w_1F_1 + \ldots + w_{n-1}F_{n-1}\\ &amp;&amp;+ (1 - w_1 - \ldots - w_{n-1})F_n. \end{align}
</p>
<p> The constructor takes a <code>vector</code> of weights \(w_i\) and a <code>vector</code> of components \(F_i\). If the two <code>vector</code>s are of equal length the extended version is used; if there is one more component than weight, the unextended version; anything else is an error. There is also a special-case constructor taking a single weight and two components, to save creating the <code>vector</code>s in this common case.</p>
<p class="startli">Note that this PDF overrides the <code>sumOfNll</code> method; if an extended <code>AddPdf</code> is used as a top-level PDF (that is, sent to <code>FitManager</code> for fitting), an additional term for the number of events will be added to the NLL.</p>
<p class="startli">Also note that if the <code>AddPdf</code>’s options mask (set by calling <code>setSpecialMask</code>) includes <code>ForceCommonNorm</code>, the normalisation changes. By default the components are normalized separately, so that </p><p class="formulaDsp">
\begin{align} P(x;\vec F, \vec w) &amp;=&amp; \sum\limits_i \frac{w_iF_i(x)}{\int F_i(x) \mathrm{d}x}, \end{align}
</p>
<p> but with <code>ForceCommonNorm</code> set, the integral is instead taken at the level of the sum: </p><p class="formulaDsp">
\begin{align} P(x;\vec F, \vec w) &amp;=&amp; \frac{\sum\limits_i w_iF_i(x)}{\int\sum\limits_i w_iF_i(x)\mathrm{d}x}. \end{align}
</p>
<p> The difference is subtle but sometimes important.</p>
</li>
<li><p class="startli"><code>BinTransformPdf</code>: Returns the global bin of its argument; in one dimension: </p><p class="formulaDsp">
\begin{align} P(x;l,s) &amp;=&amp; \mathrm{floor}\left(\frac{x-l}{s}\right) \end{align}
</p>
<p> where \(l\) is the lower limit and \(s\) is the bin size. The utility of this is perhaps not immediately obvious; one application is as an intermediate step in a <code>MappedPdf</code>. For example, suppose I want to model a \(y\) distribution with a different set of parameters in five slices of \(x\); then I would use a <code>BinTransformPdf</code> to calculate which slice each event is in.</p>
<p class="startli">The constructor takes <code>vector</code>s of the observables \(\vec x\), lower bounds \(\vec l\), bin sizes \(\vec b\), and number of bins \(\vec n\). The last is used for converting local (i.e. one-dimensional) bins into global bins in the case of multiple dimensions.</p>
</li>
<li><code>CompositePdf</code>: A chained function, <p class="formulaDsp">
\begin{align} P(x) &amp;=&amp; h(g(x)). \end{align}
</p>
 The constructor takes the kernel function \(g\) and the shell function \(h\). Note that only one-dimensional composites are supported - \(h\) cannot take more than one argument. The core function \(g\) can take any number.</li>
<li><p class="startli"><code>ConvolutionPdf</code>: Numerically calculates a convolution integral</p>
<p class="formulaDsp">
\begin{align} P(x;f,g) &amp;=&amp; f\otimes g = \int\limits_{-\infty}^\infty f(t) g(x-t) \mathrm{d}t. \end{align}
</p>
<p> The constructor takes the observable \(x\), model function \(f\), and resolution function \(g\).</p>
<p class="startli">The implementation of this function is a little complicated and relies on caching. There is a variant constructor for cases where several convolutions may run at the same time, eg a <code>MappedPdf</code> where all the targets are convolutions. This variant does cooperative loading of the caches, which is a <em>really neat</em> optimisation and ought to work a lot better than it, actually, does. Its constructor takes the observable, model, and resolution as before, and an integer indicating how many other convolutions are going to be using the same cache space.</p>
</li>
<li><code>EventWeightedAddPdf</code>: A variant of <code>AddPdf</code>, in which the weights are not fit parameters but rather observables. It otherwise works the same way as <code>AddPdf</code>; the constructor takes <code>vector</code>s of the weights and components, and it has extended and non-extended variants. Note that you should not mix-and-match; the weights must be either all observables or all fit parameters.</li>
<li><code>MappedPdf</code>: A function having the form <p class="formulaDsp">
\begin{align} F(x) &amp;=&amp; \left\{ \begin{matrix} F_1(x) &amp; x_0 \le x \le x_1 \\ F_2(x) &amp; x_1 &lt; x \le x_2 \\ (\ldots) &amp; (\ldots) \\ F_n(x) &amp; x_{n-1} &lt; x \le x_n \\ \end{matrix} \right. \end{align}
</p>
 The constructor takes a <em>mapping function</em> \(m\), which returns an index; and a <code>vector</code> of evaluation functions \(\vec F\), so that if \(m\) is zero, the PDF returns \(F_0\), and so on. Notice that \(m\) does not strictly need to return an integer - in fact the constraints of <a class="el" href="namespace_goo_fit.html">GooFit</a> force it to return a floating-point number - since <code>MappedPdf</code> will round the result to the nearest whole number. The canonical example of a mapping function is <code>BinTransformPdf</code>.</li>
<li><p class="startli"><code>ProdPdf</code>: A product of two or more PDFs: </p><p class="formulaDsp">
\begin{align} P(x; \vec F) &amp;=&amp; \prod\limits_i F_i(x). \end{align}
</p>
<p> The constructor just takes a <code>vector</code> of the functions to be multiplied.</p>
<p class="startli"><code>ProdPdf</code> does allow variable overlaps, that is, the components may depend on the same variable, eg \(P(x) = A(x)B(x)\). If this happens, the entire <code>ProdPdf</code> object will be normalized together, since in general \(\int A(x)B(x) \mathrm{d}x \ne \int A(x) \mathrm{d}x \int B(x) \mathrm{d}x\). However, if any of the components have the flag <code>ForceSeparateNorm</code> set, as well as in the default case that the components depend on separate observables, each component will be normalized individually. Some care is indicated when using the <code>ForceSeparateNorm</code> flag, and possibly a rethink of why there is a product of two PDFs depending on the same variable in the first place.</p>
</li>
</ul>
<h2>Specialised amplitude-analysis functions </h2>
<p>These functions exist mainly for use in a specific physics analysis, mixing in \(D^0\to\pi\pi\pi^0\). Nonetheless, if you are doing a Dalitz-plot analysis, you may find them, and conceivably even this documentation, helpful.</p>
<ul>
<li><code>DalitzPlotPdf</code>: A time-independent description of the Dalitz plot as a coherent sum of resonances: <p class="formulaDsp">
\begin{align} P(m^2_{12},m^2_{13};\vec\alpha) &amp;=&amp; \left|\sum\limits_i \alpha_i B_i(m^2_{12},m^2_{13})\right|^2\epsilon(m^2_{12},m^2_{13}) \end{align}
</p>
 where \(\alpha_i\) is a complex coefficient, \(B_i\) is a resonance parametrisation (see <code>ResonancePdf</code>, below), and \(\epsilon\) is a real-valued efficiency function. The constructor takes the squared-mass variables \(m_{12}\) and \(m_{13}\), an event index (this is used in caching), a <code>DecayInfo</code> object which contains a <code>vector</code> of <code>ResonancePdf</code>s as well as some global information like the mother and daughter masses, and the efficiency function.</li>
<li><code>DalitzVetoPdf</code>: Tests whether a point is in a particular region of the Dalitz plot, and returns zero if so, one otherwise. Intended for use as part of an efficiency function, excluding particular regions - canonically the one containing the \(K^0\to\pi\pi\) decay, as a large source of backgrounds that proved hard to model. The constructor takes the squared-mass variables \(m_{12}\) and \(m_{13}\), the masses (contained in <code>Variable</code>s) of the mother and three daughter particles involved in the decay, and a <code>vector</code> of <code>VetoInfo</code> objects. The <code>VetoInfo</code> objects just contain a cyclic index (either <code>PAIR_12</code>, <code>PAIR_13</code>, or <code>PAIR_23</code>) and the lower and upper bounds of the veto region.</li>
<li><code>IncoherentSumPdf</code>: Similar to <code>DalitzPlotPdf</code>, but the resonances are added incoherently: <p class="formulaDsp">
\begin{align} P(m^2_{12},m^2_{13};\vec\alpha) &amp;=&amp; \sum\limits_i \left|\alpha_i B_i(m^2_{12},m^2_{13})\right|^2\epsilon(m^2_{12},m^2_{13}) \end{align}
</p>
 The constructor is the same, but note that the <code>amp_imag</code> member of <code>ResonancePdf</code> is not used, so the \(\alpha\) are in effect interpreted as real numbers.</li>
<li><code>MixingTimeResolution</code>: (in <code><a class="el" href="_mixing_time_resolution___aux_8h.html">MixingTimeResolution_Aux.h</a></code>) The abstract base class of <code>TruthResolution</code> and <code>ThreeGaussResolution</code>. Represents a parametrisation of the time resolution.</li>
<li><code>ResonancePdf</code>: Represents a resonance-shape parametrisation, the \(B_i\) that appear in the equations for <code>DalitzPlotPdf</code>, <code>IncoherentSumPdf</code>, and <code>TddpPdf</code>. Canonically a relativistic Breit-Wigner. The constructor takes the real and imaginary parts of the coefficient \(\alpha\) (note that this is actually used by the containing function), and additional parameters depending on which function the resonance is modelled by:<ul>
<li>Relativistic Breit-Wigner: Mass, width, spin, and cyclic index. The two last are integer constants. Only spins 0, 1, and 2 are supported.</li>
<li>Gounaris-Sakurai parametrisation: Spin, mass, width, and cyclic index. Notice that this is the same list as for the relativistic BW, just a different order.</li>
<li>Nonresonant component (ie, constant across the Dalitz plot): Nothing additional.</li>
<li>Gaussian: Mean and width of the Gaussian, cyclic index. Notice that the Gaussian takes the mass \(m_{12,13,23}\) as its argument, not the squared mass \(m^2_{12,13,23}\) like the other parametrisations.</li>
</ul>
</li>
<li><p class="startli"><code>TddpPdf</code>: If the Gaussian is a potato, this is a five-course banquet dinner involving entire roasted animals stuffed with other animals, large dance troupes performing between the courses, an orchestra playing in the background, and lengthy speeches. There will not be a vegetarian option. Without going too deeply into the physics, the function models a decay, eg \(D^0\to\pi\pi\pi^0\), that can happen either directly or through a mixed path \(D^0\to \overline{D^0}\to\pi\pi\pi^0\). (Although developed for the \(\pi\pi\pi^0\) case, it should be useful for any decay where the final state is its own anti-state.) The probability of the mixing path depends on the decay time, and quantum-mechanically interferes with the direct path. Consequently the full Time-Dependent Dalitz-Plot (Tddp) amplitude is (suppressing the dependence on squared masses, for clarity): </p><p class="formulaDsp">
\begin{align} \label{eq:fullmix} P(m^2_{12}, m^2_{13}, t, \sigma_t;x,y,\tau,\vec\alpha) &amp;=&amp; e^{-t/\tau}\Big(|A+B|^2\cosh(yt/\tau)\\ &amp;&amp; + |A-B|^2\cos(xt/\tau)\\ &amp;&amp; - 2\Re(AB^*)\sinh(yt/\tau)\\ &amp;&amp; - 2\Im(AB^*)\sin(xt/\tau)\Big) \end{align}
</p>
<p> where (notice the reversed masses in the \(B\) calculation) </p><p class="formulaDsp">
\begin{align} A &amp;=&amp; \sum\limits_i \alpha_iB_i(m^2_{12}, m^2_{13}) \\ B &amp;=&amp; \sum\limits_i \alpha_iB_i(m^2_{13}, m^2_{12}), \end{align}
</p>
<p> <em>convolved with</em> a time-resolution function and <em>multiplied by</em> an efficiency. The implementation involves a large amount of caching of the intermediate \(B_i\) values, because these are expected to change slowly relative to the coefficients \(\alpha\) (in many cases, not at all, since masses and widths are often held constant) and are relatively expensive to calculate.</p>
<p class="startli">The constructor takes the measured decay time \(t\), error on decay time \(\sigma_t\), squared masses \(m^2_{12}\) and \(m^2_{13}\), event number, decay information (the same class as in <code>DalitzPlotPdf</code>; it also holds the mixing parameters \(x\) and \(y\) and lifetime \(\tau\)), time-resolution function, efficiency, and optionally a mistag fraction. A variant constructor takes, instead of a single time-resolution function, a <code>vector</code> of functions and an additional observable \(m_{D^0}\); in this case the resolution function used depends on which bin of \(m_{D^0}\) the event is in, and the number of bins is taken as equal to the number of resolution functions supplied.</p>
<p class="startli">It is not suggested to try to use this thing from scratch. Start with a working example and modify it gradually.</p>
</li>
<li><code>ThreeGaussResolution</code>: A resolution functon consisting of a sum of three Gaussians, referred to as the ‘core’, ‘tail’, and ‘outlier’ components. The constructor takes the core and tail fractions (the outlier fraction is 1 minus the other two), core mean and width, tail mean and width, and outlier mean and width. Notice that this is a resolution function, so the full probability is found by convolving Gaussians with Equation \(\ref{eq:fullmix}\), and this runs to a page or so of algebra involving error functions. It is beyond the scope of this documentation.</li>
<li><p class="startli"><code>TrigThresholdPdf</code>: Intended as part of an efficiency function, modelling a gradual fall-off near the edges of phase space:</p>
<p class="formulaDsp">
\begin{align} P(x;a,b,t) &amp;=&amp; \left\{\begin{matrix} 1 &amp; d &gt; 1/2 \\ a + (1-a) \sin(d\pi) &amp; \mathrm{otherwise} \end{matrix} \right. \end{align}
</p>
<p> where \(d=b(x-t)\) or \(d=b(t-x)\) depending on whether the function is modelling a lower or upper threshold. The constructor takes the observable \(x\) (which will be either \(m^2_{12}\) or \(m^2_{13}\)), threshold value \(t\), trig constant \(b\), linear constant \(a\), and a boolean which if true indicates an upper threshold. A variant constructor, for modelling a threshold in the “third” Dalitz-plot dimension \(m^2_{23}\), takes both \(m^2_{12}\) and \(m^2_{13}\), and an additional mass constant \(m\); it then forms \(x = m - m^2_{12} - m^2_{13}\), and otherwise does the same calculation.</p>
</li>
<li><code>TruthResolution</code>: The simplest possible resolution function, a simple delta spike at zero - i.e., time is always measured perfectly. The constructor takes no arguments at all!</li>
</ul>
<p><a class="anchor" id="footnote1"></a>1: Named in homage to RooFit, with the ‘G’ standing for ‘GPU’.</p>
<p><a class="anchor" id="footnote2"></a>2: Although, if they are <em>Buddhist</em> masters, they don’t even though they can, since they have transcended desire - and suffering with it.</p>
<p><a class="anchor" id="footnote3"></a>3: For historical reasons, MINUIT always minimises rather than maximising.</p>
<p><a class="anchor" id="footnote4"></a>4: You might ask, why not copy the function directly? The reason is that <code>cudaMemcpy</code> doesn’t like to get the address of a function, but <code>nvcc</code> is perfectly happy to statically initialize a pointer. It’s a workaround, in other words.</p>
<p><a class="anchor" id="footnote5"></a>5: These are, respectively, ancient FORTRAN code translated line-by-line into C++, almost literally by the addition of semicolons; someone’s obsessively-detailed object-oriented implementation of the same algorithm, with the same spaghetti logic chopped into classes instead of lines of code; and what seems to be intended as a common interface for a large number of possible fitting backends, which falls a little flat since it has only the MINUIT backend to talk to. You pays your money and takes your choice.</p>
<p><a class="anchor" id="footnote6"></a>6: A global bin ranges from 0 to \(n_1n_2\ldots n_N-1\) where \(n_j\) is the number of bins in the \(j\)th variable and \(N\) is the number of variables. In two dimensions, with three bins in each of \(x\) and \(y\), the global bin is given by \(3b_y+b_x\), where \(b_{x,y}\) is the bin number in \(x\) or \(y\) respectively, as shown here:</p>
<p class="formulaDsp">
\[ \begin{array}{l|ccc} 2 &amp; 6 &amp; 7 &amp; 8 \\ 1 &amp; 3 &amp; 4 &amp; 5 \\ 0 &amp; 0 &amp; 1 &amp; 2 \\ \hline &amp; 0 &amp; 1 &amp; 2 \end{array} \]
</p>
<p> where the leftmost column and bottom row indicate the \(y\) and \(x\) bin number.</p>
<p><a class="anchor" id="footnote7"></a>7: That is, <code>__shared__</code> for the default CUDA target.</p>
<p><a class="anchor" id="footnote8"></a>8: This is why <code>functorConstants[0]</code> is reserved for that value!</p>
<p><a class="anchor" id="footnote9"></a>9: On the grounds that ten dimensions should be enough for anyone!</p>
<p><a class="anchor" id="footnote10"></a>10: Oops, there’s that potato after all. It’s a contrived example.</p>
<p><a class="anchor" id="footnote11"></a>11: If this seems complicated, spare a thought for the hapless ergrad who had to code the original CPU version.</p>
<p><a class="anchor" id="footnote12"></a>12: Although being honest, just supporting the special cases of one and two would likely have sufficed. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 7 2017 20:18:28 for GooFit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
